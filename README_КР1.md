1.	Блочная (корзинная) сортировка.
Корзинная (блочная) сортировка — это алгоритм, который разбивает набор данных на несколько корзин по диапазону значений, сортирует каждую корзину отдельно, а затем объединяет все корзины для получения отсортированного массива.
Оценка временной сложности в нотации Big(O):
Здесь основная часть — сортировка элементов внутри корзин. В среднем случае:
•	Распределение элементов по корзинам — (O(n))
•	Сортировка каждой корзины — в среднем за (O((n/k) \log(n/k))), где (k) — количество корзин
Общая сложность примерно:
[ O(n) + k \times O((n/k) \log(n/k)) = O(n) + O(n \log(n/k)) ]
При постоянном количестве корзин (k) итоговая сложность — O(n \log n).
Краткое объяснение:
Сортировка по корзинам делит входной массив на корзины по диапазонам значений, сортирует каждую корзину и объединяет их. Время выполнения зависит от равномерности распределения данных и выбранного количества корзин. В среднем это порядок (O(n \log n)); в худшем случае, при неудачном распределении элементов, может достигать (O(n^2)).


2.	блинная сортировка.
Блинная сортировка (или пузырьковая сортировка) — это алгоритм, который многократно перебирает массив, сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке, до тех пор, пока весь массив не будет отсортирован.
Оценка временной сложности в нотации Big(O):
•	В худшем случае: каждый элемент нужно сравнить со всеми оставшимися, итерации выполняются (n-1), (n-2), ..., 1 раз, итого примерно (\frac{n(n-1)}{2} \sim O(n^2)).
•	В лучшем случае (если массив уже отсортирован): один проход без перестановок — сложность (O(n)), но в общем случае считается, что пузырьковая сортировка — это (O(n^2)).
Краткое объяснение:
«Сортировка блинчиками» последовательно перебирает массив, сравнивает соседние элементы и при необходимости меняет их местами, «выталкивая» максимальный элемент в конец за каждый проход. Этот процесс повторяется до тех пор, пока весь массив не будет отсортирован. В худшем случае она работает за квадратичное время — (O(n^2)).


3.	сортировка бусинами (гравитационная)
Гравитационная сортировка — это разновидность пузырьковой сортировки, при которой на каждом проходе больший элемент «падает» вниз, меняясь местами с меньшими элементами, пока весь массив не будет отсортирован.
Оценка временной сложности:
В худшем случае, при необходимости перебора всех элементов, алгоритм будет выполнять примерно ( n ) проходов, а каждый проход — ( O(n) ) сравнений, итого:[ O(n^2) ]
Если массив уже отсортирован, достаточно одного прохода —[ O(n) ]
Краткое объяснение:
Этот алгоритм последовательно сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке, «опуская» большие элементы вниз. Он повторяет эти действия до тех пор, пока последовательность не будет полностью отсортирована. В худшем случае сложность будет квадратичной, в среднем и лучшем — линейной.


4.	поиск скачками.
Алгоритм поиска скачками — это метод поиска, при котором массив разбивается на блоки фиксированной длины. Переход по блокам осуществляется с шагом, равным корню из размера массива, до тех пор, пока не будет найден блок, содержащий искомый элемент, после чего внутри этого блока выполняется линейный поиск.
Оценка временной сложности:
•	В худшем случае, чтобы найти элемент или убедиться в его отсутствии, алгоритм проверяет блоки и их элементы, что занимает:
[ O(\sqrt{n}) \text{ (для поиска блока)} + O(\sqrt{n}) \text{ (поиск внутри блока)} = O(\sqrt{n}) ]
•	Итоговая сложность: O(√n).
Краткое объяснение:
Этот алгоритм использует скачки по массиву с шагом, равным корню из размера массива, что позволяет быстрее перемещаться по отсортированному массиву, значительно сокращая количество сравнений по сравнению с линейным поиском и достигая в худшем случае сложности, пропорциональной квадратному корню из длины массива.


5.	экспоненциальный поиск.
Экспоненциальный поиск — это алгоритм поиска в отсортированном массиве, который сначала экспоненциально увеличивает диапазон поиска, чтобы найти потенциальное местоположение искомого элемента, а затем выполняет бинарный поиск внутри этого диапазона.
Оценка временной сложности:
•	В худшем случае экспоненциальное увеличение диапазона занимает (O(\log n)), так как граница удваивается на каждом шаге.
•	После этого бинарный поиск выполняется за (O(\log n)) в определённом диапазоне.
•	В итоге общая сложность составляет O(log n).
Краткое объяснение:
Сначала алгоритм ищет диапазон, в котором может находиться искомый элемент, экспоненциально расширяя границы поиска. После определения подходящего диапазона выполняется бинарный поиск в этом диапазоне. Такой подход очень эффективен в случаях, когда искомый элемент находится в начале массива или когда его позиция неизвестна, и обеспечивает логарифмическую временную сложность.


6.	тернарный поиск.
Тернарный поиск — это расширение бинарного поиска, при котором отсортированный массив делится на три части, а искомое значение сравнивается с двумя опорными элементами, чтобы определить, в какой из трёх частей искать дальше.
Оценка временной сложности:
•	На каждом этапе диапазон делится на три части, что даёт примерно ( \log_3 n ) итераций.
•	Каждая итерация состоит из нескольких сравнений и вычислений — ( O(1) ).
Следовательно, итоговая сложность: O(log₃ n), что по сути равно ( O(\log n) ), так как основание логарифма в нотации Big(O) не имеет значения.
Краткое объяснение:
Тернарный поиск делит массив на три части и сравнивает искомое значение с двумя центральными элементами, сужая диапазон поиска в три раза за шаг. Этот подход сохраняет логарифмическую эффективность и может быть чуть быстрее бинарного поиска за счёт меньшего количества итераций при прочих равных условиях.
